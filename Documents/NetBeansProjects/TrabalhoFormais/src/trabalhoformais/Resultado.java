/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package trabalhoformais;

import java.util.ArrayList;
import java.util.Arrays;
import javax.swing.JOptionPane;

/**
 *
 * @author Gabriel Patatt
 */
public class Resultado extends javax.swing.JFrame {

    /**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
     * Creates new form Resultado
     */
    public Resultado() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        lblCodGerado = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtSol = new javax.swing.JTextArea();
        jLabel3 = new javax.swing.JLabel();
        lblGramatica = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setText("Código gerado:");

        lblCodGerado.setText("Gramatica");

        jLabel2.setText("Possíveis soluções:");

        txtSol.setColumns(20);
        txtSol.setRows(5);
        jScrollPane1.setViewportView(txtSol);

        jLabel3.setText("Tipo de Gramática:");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(lblCodGerado))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(lblGramatica)))
                .addContainerGap(108, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(lblCodGerado))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel2)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(16, 16, 16)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(lblGramatica))
                .addContainerGap(125, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        
       
        
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Resultado().setVisible(true);
            }
        });
    }
    
     public void Recebe(String naoTerminal, String terminal, String [] prod, String inicial, String conjProd, String [] prod2, String [] prod3, String expCheia ){
         String resultadoExpressao = "";
         System.out.println(naoTerminal);
         geraGramatica(naoTerminal, terminal, conjProd, inicial);
         montagemProducao(prod,prod2,prod3);
         resultadoExpressao = implementaVerificaValores(prod,prod2,prod3);
         lblGramatica.setText(resultadoExpressao);
         
     } 
     public void montagemProducao(String [] prod, String [] prod2, String [] prod3){
          /*Monta a gramática, com os valores posicionados diretamente do usuário.*/       
          if(prod.length > 1){  
            /*Testa se o vetor tem mais de uma posição, se tiver ele entra no vetor, 
              ele no minimo sempre terá uma. */
            for (int i = 0; i < prod.length; i++) {
                if (i == 0) 
                   /*Testa, se o i for zero será a primeira posição do vetor, 
                    logo será o primeiro valor nâo terminal.*/
                   txtSol.append(prod[i] + "=>");
                else 
                    /*Se não, printa normalmente! */
                   txtSol.append(prod[i]);
                if(i == prod.length-1) 
                    /* Testa se está na ultima posição o vetor, 
                    caso estiver ele quebra a linha para o próximo. */
                   txtSol.append("\n");  
                else if(i > 0)  
                    /*Se não, coloca a vírgula no final. */
                    txtSol.append(","); 
            }
          }
          
          
          if(prod2.length > 1){
              /*Testa se o vetor tem mais de uma posição, se tiver ele entra no vetor, 
              ele no minimo sempre terá uma. */
               for (int i = 0; i < prod2.length; i++) {
                    if (i == 0)
                       /*Testa, se o i for zero será a primeira posição do vetor, 
                        logo será o primeiro valor nâo terminal.*/
                       txtSol.append(prod2[i] + "=>");
                    else
                        /*Se não, printa normalmente */
                       txtSol.append(prod2[i]);
                    if(i == prod2.length-1)
                        /* Testa se está na ultima posição o vetor, 
                        caso estiver ele quebra a linha para o próximo. */
                       txtSol.append("\n");  
                    else if(i > 0)
                        /*Se não, coloca a vírgula no final. */
                       txtSol.append(","); 
                   
                }
          }
          
          if(prod3.length > 1){
              /*Testa se o vetor tem mais de uma posição, se tiver ele entra no vetor, 
              ele no minimo sempre terá uma. */
               for (int i = 0; i < prod3.length; i++) {
                    if (i == 0)
                       /*Testa, se o i for zero será a primeira posição do vetor, 
                        logo será o primeiro valor nâo terminal.*/
                       txtSol.append(prod3[i] + "=>");
                    else
                        /*Se não, printa normalmente */
                       txtSol.append(prod3[i]);
                    if(i == prod3.length-1)
                        /* Testa se está na ultima posição o vetor, 
                        caso estiver ele quebra a linha para o próximo. */
                       txtSol.append("\n");  
                    else if(i > 0)
                        /*Se não, coloca a vírgula no final. */
                       txtSol.append(","); 
                }
      }
}          
      
     public static String juntaProducao (String [] prod, String [] prod2, String [] prod3 ){
         ArrayList<String> producoes = new ArrayList<>();
         ArrayList<String> producoes2 = new ArrayList<>();
         ArrayList<String> producoes3 = new ArrayList<>();
         /*Criação de uma lista de armazenamento de Strings. */
         String junto = "", junto2 = "", junto3 = "", juntaTudo = "";
         producoes.addAll(Arrays.asList(prod));
         producoes2.addAll(Arrays.asList(prod2));
         producoes3.addAll(Arrays.asList(prod3));
         /*Adiciona o vetor de strings na lista.*/
         for (int i = 0; i < producoes.size(); i++) {
             junto = junto+producoes.get(i);
             /*Junta as palavras.*/
         }
         for (int i = 0; i < producoes2.size(); i++) {
             junto2 = junto2+producoes2.get(i);
             /*Junta as palavras.*/
         }
         for (int i = 0; i < producoes3.size(); i++) {
             junto3 = junto3+producoes3.get(i);
             /*Junta as palavras.*/
         }
         
         juntaTudo = junto + junto2 + junto3;
      
         return juntaTudo;
          
      }
     
     public void geraGramatica(String naoTerminal, String terminal, String conjProd, String inicial){
        
         lblCodGerado.setText("G = ({"+ naoTerminal + "},{"+ terminal +"},"+ conjProd +","+ inicial +")");
          /* Cria uma função recebe, que recebe como parâmetro, os dados do JFRAME interface, 
         para assim o usuário ficar com uma melhor visibilidade do código proposto.*/
     }
     
     public int retornaRegular(String [] prod){
         int entrei = 0;
         /*Inicializa contador!*/
         if(prod[0].charAt(0) >= 91 && prod[0].charAt(0)<=122) {
             /*Verifica se há algum terminal no lado esquerdo, caso sim, é não regular*/
             JOptionPane.showMessageDialog (null, "Esta gramática não é regular nem livre de contexto devido a começar com valor terminal no lado esquerdo!");
             System.exit(1);
         }
             
            for (int i = 1; i < prod.length; i++) {
                
                /*Faz um for a partir da posição 1 para testar diretamente as palavras*/
                   if(prod[0].length()>1){
                       /*Testa se o tamanho do lado esquerdo for maior que 1, significa que não há somente um 
                       não terminal, logo já não é regular!*/
                       JOptionPane.showMessageDialog (null, "Esta sentença não é regular devido a começar com mais de um valor no lado esquerdo!");
                       System.exit(1);
                   }
                   else if(prod[i].length()>0){
                       /*Se não, ele testa, a partir do for, se a expressão na posição i
                       é maior que zero, para verificar se não há nenhum nao terminal sozinho!
                       */
                        if(prod[i].length()==1){
                           if(prod[i].charAt(0) >= 91  && prod[i].charAt(0)<=122 || prod[i].charAt(0) == 38){
                               /*Vai verificar se tem somente uma letra e se esta letra é terminal*/
                               entrei++;
                           }
                        }
                   else if((prod[i].substring(0,1).charAt(0) >= 97 && 
                            prod[i].substring(0,1).charAt(0)<=122) && 
                           (prod[i].substring(1,2).charAt(0) >= 64 &&
                            prod[i].substring(1,2).charAt(0)<=91))
                                  entrei++;       
                                  /*Se não tiver um terminal sozinho, a regra diz que só podera ter um 
                                  não terminal seguido de um terminal, caso essas regras forem favorecidas
                                  haverá uma incrementação no entrei.*/
                   }
            }
            
            
             if(entrei == prod.length-1)
                return 1;
             /*Se o contador entrei, estiver com valor igual a o tamanho do produto -1(devido a primeira letra)
             Logo a expressão será regular!*/
             else
                return 0;
       
            
     }
     
     private String implementaVerificaValores(String [] prod, String [] prod2, String [] prod3 ) {
        ArrayList<Integer> valores = new ArrayList<Integer>();
        int somaVerdadeiros = 0;
        valores.add(retornaRegular(prod));
        valores.add(retornaRegular(prod2));
        valores.add(retornaRegular(prod3));
         for (int i = 0; i < valores.size(); i++) {
             if(valores.get(i) == 1)
                 somaVerdadeiros++;
         }
         if(somaVerdadeiros == valores.size())
             return "Gramática regular!";
         else
             return "Gramática Livre de Contexto!";
    }
     
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel lblCodGerado;
    private javax.swing.JLabel lblGramatica;
    private javax.swing.JTextArea txtSol;
    // End of variables declaration//GEN-END:variables


}
